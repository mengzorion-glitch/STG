# V0.4.0 - 怪物系統 詳細步驟

## 步驟 0：怪物資源結構

在 `public/monster/` 下放置怪物圖檔：

```
public/monster/
├── mob_small_0.png       (小型怪物，0.5 單位)
├── mob_small_1.png       (可選，多幀動畫)
├── mob_medium_0.png      (中型怪物，1.5 單位)
└── mob_medium_1.png      (可選，多幀動畫)
```

**命名規則：**
- 格式：`mob_{type}_{frame}.png`
- type = 怪物類型 (small, medium)
- frame = 幀編號，從 0 開始
- 格式：PNG，透明背景

**單位大小對照：**

| 類型 | 單位 | 像素 | 說明 |
|------|------|------|------|
| small | 0.5 | 54px | 小型雜魚 |
| medium | 1.5 | 162px | 中型怪物 |

---

## 步驟 1：怪物定義檔

建立 `src/data/MonsterData.ts`：

```typescript
/**
 * 行為模式
 */
export type BehaviorType = 'straight' | 'sine' | 'dash';

/**
 * 怪物定義
 */
export interface MonsterDef {
  type: string;         // 類型 ID
  hp: number;           // 血量
  damage: number;       // 碰撞傷害
  speed: number;        // 移動速度 (px/s)
  exp: number;          // 經驗值
  unitSize: number;     // 單位大小
  frameCount: number;   // 動畫幀數
  behavior: BehaviorType; // 行為模式
}

/**
 * 怪物定義表
 */
export const MONSTER_DEFS: MonsterDef[] = [
  {
    type: 'small',
    hp: 20,
    damage: 5,
    speed: 150,
    exp: 10,
    unitSize: 0.5,
    frameCount: 1,
    behavior: 'sine',
  },
  {
    type: 'medium',
    hp: 50,
    damage: 10,
    speed: 100,
    exp: 25,
    unitSize: 1.5,
    frameCount: 1,
    behavior: 'dash',
  },
];

/**
 * 取得怪物定義
 */
export function getMonsterDef(type: string): MonsterDef | undefined {
  return MONSTER_DEFS.find(m => m.type === type);
}
```

**行為模式說明：**

| 行為 | 說明 |
|------|------|
| `straight` | 單純向左直線移動 |
| `sine` | S形曲線移動 (振幅1單位，週期2秒) |
| `dash` | 衝刺-停頓循環 (前方3單位、±45度隨機，停頓1秒) |

---

## 步驟 2：怪物類別

建立 `src/entities/Monster.ts`：

```typescript
import Phaser from 'phaser';
import { UNIT_SIZE } from '../config/GameConfig';
import { MonsterDef } from '../data/MonsterData';

/**
 * 怪物實體
 * - 從畫面右側生成，向左移動
 * - 碰撞玩家造成傷害
 */
export class Monster extends Phaser.GameObjects.Sprite {
  private def: MonsterDef;
  private currentHp: number;
  private isDead: boolean = false;

  // 行為狀態
  private elapsedTime: number = 0;        // 累計時間 (sine用)
  private baseY: number = 0;              // 基準Y位置 (sine用)
  private targetX: number = 0;            // 目標X (dash用)
  private targetY: number = 0;            // 目標Y (dash用)
  private dashPauseTimer: number = 0;     // 停頓計時 (dash用)
  private isDashing: boolean = false;     // 是否正在衝刺 (dash用)

  constructor(scene: Phaser.Scene, x: number, y: number, def: MonsterDef) {
    super(scene, x, y, `mob-${def.type}-0`);
    scene.add.existing(this as Phaser.GameObjects.Sprite);

    this.def = def;
    this.currentHp = def.hp;
    this.baseY = y;

    this.setDepth(5);  // 怪物層級 (背景之上，玩家之下)
    this.setUnitSize(def.unitSize);
    this.initAnimation();
    this.initBehavior();
  }

  /**
   * 初始化行為模式
   */
  private initBehavior(): void {
    if (this.def.behavior === 'dash') {
      this.setNextDashTarget();
      this.isDashing = true;
    }
  }

  /**
   * 設定下一個衝刺目標點
   * 往前方3個單位，90度角度內隨機
   */
  private setNextDashTarget(): void {
    const distance = UNIT_SIZE * 3;
    // 90度範圍: -45度 到 +45度 (以左方為基準)
    const angle = Phaser.Math.Between(-45, 45);
    const rad = Phaser.Math.DegToRad(180 + angle); // 180度=左方

    this.targetX = this.x + Math.cos(rad) * distance;
    this.targetY = this.y + Math.sin(rad) * distance;
  }

  /**
   * 設定怪物大小 (以單位為基準)
   */
  private setUnitSize(units: number): void {
    const targetSize = UNIT_SIZE * units;
    const maxDimension = Math.max(this.width, this.height);
    const scale = targetSize / maxDimension;
    this.setScale(scale);
  }

  /**
   * 初始化動畫
   */
  private initAnimation(): void {
    const animKey = `mob-${this.def.type}-idle`;
    if (this.scene.anims.exists(animKey)) {
      this.play(animKey);
      return;
    }

    // 建立動畫
    const frames: Phaser.Types.Animations.AnimationFrame[] = [];
    for (let i = 0; i < this.def.frameCount; i++) {
      frames.push({ key: `mob-${this.def.type}-${i}` });
    }

    this.scene.anims.create({
      key: animKey,
      frames: frames,
      frameRate: 6,
      repeat: -1,
    });

    this.play(animKey);
  }

  /**
   * 每幀更新
   */
  update(delta: number): void {
    if (this.isDead) return;

    const deltaSeconds = delta / 1000;

    switch (this.def.behavior) {
      case 'sine':
        this.updateSine(deltaSeconds);
        break;
      case 'dash':
        this.updateDash(deltaSeconds);
        break;
      default:
        // straight: 單純向左
        this.x -= this.def.speed * deltaSeconds;
        break;
    }
  }

  /**
   * S形曲線移動
   */
  private updateSine(deltaSeconds: number): void {
    this.elapsedTime += deltaSeconds;

    // 向左移動
    this.x -= this.def.speed * deltaSeconds;

    // Y軸正弦波動 (振幅1單位，週期2秒)
    const amplitude = UNIT_SIZE;
    const frequency = Math.PI; // 2秒一個週期
    this.y = this.baseY + Math.sin(this.elapsedTime * frequency) * amplitude;
  }

  /**
   * 衝刺-停頓移動
   */
  private updateDash(deltaSeconds: number): void {
    if (!this.isDashing) {
      // 停頓中
      this.dashPauseTimer -= deltaSeconds;
      if (this.dashPauseTimer <= 0) {
        this.setNextDashTarget();
        this.isDashing = true;
      }
      return;
    }

    // 衝刺中 - 向目標移動
    const dx = this.targetX - this.x;
    const dy = this.targetY - this.y;
    const dist = Math.sqrt(dx * dx + dy * dy);

    if (dist < 5) {
      // 到達目標，開始停頓
      this.isDashing = false;
      this.dashPauseTimer = 1; // 停頓1秒
      return;
    }

    // 移動向目標
    const moveSpeed = this.def.speed * 2; // 衝刺速度加倍
    const moveAmount = Math.min(moveSpeed * deltaSeconds, dist);
    this.x += (dx / dist) * moveAmount;
    this.y += (dy / dist) * moveAmount;
  }

  /**
   * 受到傷害
   * @returns true 如果怪物死亡
   */
  takeDamage(amount: number): boolean {
    if (this.isDead) return false;

    this.currentHp -= amount;

    // 受擊閃爍
    this.setTint(0xff0000);
    this.scene.time.delayedCall(100, () => this.clearTint());

    if (this.currentHp <= 0) {
      this.die();
      return true;
    }
    return false;
  }

  /**
   * 死亡處理
   */
  private die(): void {
    this.isDead = true;
    // 簡單淡出效果
    this.scene.tweens.add({
      targets: this,
      alpha: 0,
      scale: this.scale * 1.5,
      duration: 200,
      onComplete: () => this.destroy(),
    });
  }

  getExp(): number {
    return this.def.exp;
  }

  getDamage(): number {
    return this.def.damage;
  }

  isAlive(): boolean {
    return !this.isDead;
  }

  getType(): string {
    return this.def.type;
  }
}
```

---

## 步驟 3：怪物系統

建立 `src/systems/MonsterSystem.ts`：

```typescript
import Phaser from 'phaser';
import { Monster } from '../entities/Monster';
import { MonsterDef, MONSTER_DEFS } from '../data/MonsterData';

/**
 * 怪物生成與管理系統
 */
export class MonsterSystem {
  private scene: Phaser.Scene;
  private monsters: Monster[] = [];
  private spawnTimer: number = 0;
  private spawnInterval: number = 2000; // 生成間隔 (ms)

  constructor(scene: Phaser.Scene) {
    this.scene = scene;
  }

  /**
   * 載入怪物資源
   */
  static preload(scene: Phaser.Scene): void {
    for (const def of MONSTER_DEFS) {
      for (let i = 0; i < def.frameCount; i++) {
        scene.load.image(
          `mob-${def.type}-${i}`,
          `monster/mob_${def.type}_${i}.png`
        );
      }
    }
  }

  /**
   * 每幀更新
   */
  update(delta: number): void {
    // 生成計時
    this.spawnTimer += delta;
    if (this.spawnTimer >= this.spawnInterval) {
      this.spawnTimer = 0;
      this.spawnRandom();
    }

    // 更新所有怪物
    for (let i = this.monsters.length - 1; i >= 0; i--) {
      const monster = this.monsters[i];
      monster.update(delta);

      // 視野外剔除 (離開畫面左側)
      if (monster.x < -100) {
        monster.destroy();
        this.monsters.splice(i, 1);
      }
    }
  }

  /**
   * 隨機生成怪物
   */
  private spawnRandom(): void {
    const def = MONSTER_DEFS[Math.floor(Math.random() * MONSTER_DEFS.length)];
    this.spawn(def);
  }

  /**
   * 生成指定類型怪物
   */
  spawn(def: MonsterDef): Monster {
    const screenW = this.scene.scale.width;
    const screenH = this.scene.scale.height;
    const x = screenW + 50;  // 畫面右側外
    const y = Phaser.Math.Between(100, screenH - 100);

    const monster = new Monster(this.scene, x, y, def);
    this.monsters.push(monster);
    return monster;
  }

  /**
   * 取得所有存活怪物
   */
  getMonsters(): Monster[] {
    return this.monsters.filter(m => m.isAlive());
  }

  /**
   * 移除怪物
   */
  removeMonster(monster: Monster): void {
    const index = this.monsters.indexOf(monster);
    if (index !== -1) {
      this.monsters.splice(index, 1);
    }
  }

  /**
   * 設定生成間隔
   */
  setSpawnInterval(ms: number): void {
    this.spawnInterval = ms;
  }

  /**
   * 清除所有怪物
   */
  destroy(): void {
    for (const monster of this.monsters) {
      monster.destroy();
    }
    this.monsters = [];
  }
}
```

---

## 步驟 4：整合到 MainScene

更新 `src/scenes/MainScene.ts`：

```typescript
import { MonsterSystem } from '../systems/MonsterSystem';

// 在類別屬性區塊加入
private monsterSystem!: MonsterSystem;

preload(): void {
  // ... 現有程式碼

  // V0.4.0: 載入怪物圖片
  MonsterSystem.preload(this);
}

create(): void {
  // ... 現有程式碼 (背景、玩家)

  // V0.4.0: 初始化怪物系統
  this.monsterSystem = new MonsterSystem(this);
}

update(_time: number, delta: number): void {
  // ... 現有程式碼

  // V0.4.0: 更新怪物
  this.monsterSystem.update(delta);
}
```

---

## 步驟 5：除錯資訊更新

更新 `updateDebugInfo` 顯示怪物數量：

```typescript
private updateDebugInfo(delta: number): void {
  const fps = Math.round(1000 / delta);
  const w = this.scale.width;
  const h = this.scale.height;
  const monsterCount = this.monsterSystem.getMonsters().length;
  const lines = [
    `FPS: ${fps}`,
    `Size: ${Math.round(w)}x${Math.round(h)}`,
    `Player: (${Math.round(this.player.x)}, ${Math.round(this.player.y)})`,
    `State: ${this.player.getState()}`,
    `Monsters: ${monsterCount}`,
  ];
  this.debugText.setText(lines.join('\n'));
}
```

---

## 資源準備清單

在 `public/monster/` 放置以下檔案：

| 類型 | 檔案 | 單位 | 行為 |
|------|------|------|------|
| 小型 | `mob_small_0.png` | 0.5 | S形曲線 |
| 中型 | `mob_medium_0.png` | 1.5 | 衝刺-停頓 |

**圖片規格：**
- 格式：PNG (透明背景)
- 命名格式：`mob_{type}_{frame}.png`

---

## 完成檢查清單

- [ ] `public/monster/mob_small_0.png` 存在
- [ ] `public/monster/mob_medium_0.png` 存在
- [ ] 怪物從畫面右側生成
- [ ] 小怪物 S形曲線移動
- [ ] 中怪物 衝刺-停頓移動
- [ ] 怪物大小依單位設定正確
- [ ] 除錯資訊顯示怪物數量
- [ ] 離開畫面左側的怪物被回收
- [ ] 效能正常 (60 FPS)
