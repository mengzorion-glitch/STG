# V0.8.0 - 遊戲優化 詳細步驟

## 需求規格

### 怪物生成數量增加
- 每波生成數量從 1 隻開始
- 每 30 秒增加 1 隻/波
- 例：0-30秒 = 1隻，30-60秒 = 2隻，60-90秒 = 3隻...

### 畫面震動效果
| 觸發條件 | 持續時間 | 強度 |
|----------|----------|------|
| 被子彈擊中 | 50ms | 0.005 |
| 被怪物碰撞 | 100ms | 0.01 |

---

## 步驟 1：怪物生成數量隨時間增加

更新 `src/systems/MonsterSystem.ts`：

```typescript
export class MonsterSystem {
  // V0.8.0: 動態生成數量
  private spawnCount: number = 1;           // 每波生成數量
  private difficultyTimer: number = 0;      // 難度計時器
  private readonly DIFFICULTY_INTERVAL = 30000; // 每 30 秒增加難度

  update(delta: number): void {
    // V0.8.0: 難度計時 (每15秒增加生成數量)
    this.difficultyTimer += delta;
    if (this.difficultyTimer >= this.DIFFICULTY_INTERVAL) {
      this.difficultyTimer = 0;
      this.spawnCount++;
    }

    // 生成計時
    this.spawnTimer += delta;
    if (this.spawnTimer >= this.spawnInterval) {
      this.spawnTimer = 0;
      this.spawnWave();  // 改為生成一波
    }
    // ...
  }

  // V0.8.0: 生成一波怪物 (數量隨時間增加)
  private spawnWave(): void {
    for (let i = 0; i < this.spawnCount; i++) {
      this.spawnRandom();
    }
  }
}
```

---

## 步驟 2：畫面震動效果

更新 `src/scenes/MainScene.ts`：

```typescript
// V0.8.0: 畫面震動效果
private shakeCamera(duration: number, intensity: number): void {
  this.cameras.main.shake(duration, intensity);
}

// 怪物子彈 vs 玩家
if (dist < hitRadius) {
  this.player.takeBulletDamage();
  this.bulletSystem.removeBullet(bullet);
  // V0.8.0: 畫面震動
  this.shakeCamera(50, 0.005);
}

// 怪物碰撞檢測
if (this.monsterSystem.checkPlayerCollision(this.player)) {
  this.collisionCooldown = this.COLLISION_COOLDOWN;
  // V0.8.0: 碰撞震動 (較強)
  this.shakeCamera(100, 0.01);
}
```

---

## 步驟 3：小怪出生點與移動方式

### 需求
- 小怪從右半螢幕的上方或下方出生
- 上方出生 → 向下移動
- 下方出生 → 向上移動
- 同時保持向左移動

### 更新行為類型

更新 `src/data/MonsterData.ts`：

```typescript
// 新增 'vertical' 行為類型
export type BehaviorType = 'straight' | 'sine' | 'dash' | 'vertical';

// 小怪改用 vertical 行為
{
  type: 'small',
  hp: 15,
  behavior: 'vertical',  // V0.8.0: 上下出生，垂直移動
  // ...
}
```

### 更新怪物實體

更新 `src/entities/Monster.ts`：

```typescript
export class Monster extends Phaser.GameObjects.Sprite {
  private verticalDir: number = 1;  // V0.8.0: 垂直方向 (1=下, -1=上)

  // V0.8.0: 垂直移動 (上下出生，朝反方向移動) + 環形彈幕
  private updateVertical(deltaSeconds: number): void {
    // 向左移動
    this.x -= this.def.speed * deltaSeconds;

    // 垂直移動 (速度較慢)
    this.y += this.verticalDir * this.def.speed * 0.5 * deltaSeconds;

    // 每3秒發射8發環形子彈
    this.attackTimer += deltaSeconds;
    if (this.attackTimer >= 3 && this.bulletSystem) {
      this.attackTimer = 0;
      this.bulletSystem.fireCircle(this.x, this.y, 8);
      this.soundManager?.play('monsterAttack');
    }
  }

  // V0.8.0: 設定垂直移動方向
  setVerticalDirection(dir: number): void {
    this.verticalDir = dir;
  }
}
```

### 更新生成邏輯

更新 `src/systems/MonsterSystem.ts`：

```typescript
spawn(def: MonsterDef): Monster {
  const screenW = this.scene.scale.width;
  const screenH = this.scene.scale.height;

  let x: number;
  let y: number;
  let verticalDir = 0;

  // V0.8.0: 小怪從右半螢幕上下兩側出生
  if (def.behavior === 'vertical') {
    // X: 右半螢幕隨機 (螢幕中間到右側外)
    x = Phaser.Math.Between(Math.floor(screenW / 2), screenW + 50);
    // Y: 上方或下方隨機
    const spawnTop = Math.random() < 0.5;
    if (spawnTop) {
      y = Phaser.Math.Between(-50, 50);  // 上方出生
      verticalDir = 1;  // 向下移動
    } else {
      y = Phaser.Math.Between(screenH - 50, screenH + 50);  // 下方出生
      verticalDir = -1;  // 向上移動
    }
  } else {
    // 其他怪物：右側外，Y軸隨機
    x = screenW + 50;
    y = Phaser.Math.Between(100, screenH - 100);
  }

  const monster = new Monster(this.scene, x, y, def);

  // V0.8.0: 設定垂直方向
  if (verticalDir !== 0) {
    monster.setVerticalDirection(verticalDir);
  }
  // ...
}
```

---

## 步驟 4：手機版雙指點擊施放大技能

### 需求
- 電腦版：右鍵施放大技能 (維持不變)
- 手機版：雙指同時點擊螢幕施放大技能
- 雙指觸發時不執行普通攻擊，避免誤射

### 更新輸入系統

更新 `src/scenes/MainScene.ts`：

```typescript
export class MainScene extends Phaser.Scene {
  // #region 輸入系統
  private isLeftDown: boolean = false;
  private fireTimer: number = 0;
  private readonly FIRE_INTERVAL = 200;
  // V0.8.0: 雙指觸發大技能 (手機版)
  private twoFingerStartTime: number = 0;
  private readonly TWO_FINGER_THRESHOLD = 150; // 雙指判定時間閾值 (ms)
  // #endregion 輸入系統

  init(): void {
    // 重置所有狀態
    this.isLeftDown = false;
    this.fireTimer = 0;
    this.twoFingerStartTime = 0;  // V0.8.0: 重置雙指計時
    // ...
  }

  private setupInput(): void {
    this.input.mouse!.disableContextMenu();

    this.input.on('pointerdown', (pointer: Phaser.Input.Pointer) => {
      // V0.8.0: 檢測雙指點擊 (手機版施放大技能)
      const activePointers = this.countActivePointers();
      if (activePointers >= 2) {
        this.onRightClick();  // 雙指同時按下，觸發大技能
        return;  // 不執行普通攻擊
      }

      // 單指：記錄時間，用於判斷是否為雙指操作的第一指
      if (activePointers === 1) {
        this.twoFingerStartTime = this.time.now;
      }

      // 左鍵/單指：發射 + 移動
      if (pointer.leftButtonDown()) {
        this.isLeftDown = true;
        this.fireTimer = 0;
        this.bulletSystem.firePlayerSpread(this.player.x + 30, this.player.y);
        this.player.setPlayerState('attack');
        this.player.setTargetPosition(new Phaser.Math.Vector2(pointer.x, pointer.y));
        this.soundManager.play('shoot');
      }

      // 右鍵 (電腦版)
      if (pointer.rightButtonDown()) {
        this.onRightClick();
      }
    });
    // ...
  }

  /**
   * V0.8.0: 計算當前活躍的觸控點數量
   */
  private countActivePointers(): number {
    let count = 0;
    if (this.input.pointer1?.isDown) count++;
    if (this.input.pointer2?.isDown) count++;
    return count;
  }
}
```

### 觸發方式對照表

| 平台 | 操作方式 | 說明 |
|------|----------|------|
| 電腦 | 右鍵點擊 | 維持原有操作 |
| 手機 | 雙指同時點擊 | 兩根手指同時觸碰螢幕 |

---

## 完成檢查清單

- [ ] 怪物生成數量隨時間增加 (每30秒 +1隻/波)
- [ ] 被子彈擊中畫面震動 (50ms, 0.005)
- [ ] 被怪物碰撞畫面震動 (100ms, 0.01)
- [ ] 小怪從右半螢幕上下兩側出生
- [ ] 上方出生向下移動，下方出生向上移動
- [ ] 新增 'vertical' 行為類型
- [ ] 手機版雙指點擊施放大技能
- [ ] 新增 countActivePointers() 方法
