# V0.3.0 - 角色系統 詳細步驟

## 步驟 0：單位系統定義

更新 `src/config/GameConfig.ts`，加入單位定義：

```typescript
/**
 * 單位系統
 * 1 單位 = 畫面高度的 10% = 108px
 * 用於統一遊戲內物件的大小定義
 */
export const UNIT_SIZE = GAME_HEIGHT * 0.1;  // 108px
```

**單位系統說明：**

| 單位 | 像素 | 用途 |
|------|------|------|
| 1 單位 | 108px | 玩家角色大小 |
| 0.5 單位 | 54px | 小型敵人/子彈 |
| 2 單位 | 216px | 大型 Boss |

> 所有遊戲物件的大小都應以單位為基準，確保視覺比例一致。

---

## 步驟 1：角色資源結構

在 `public/player/` 下放置角色圖檔：

```
public/player/
├── player_idle_0.png    (必要，至少一張)
├── player_idle_1.png    (可選，多幀循環)
├── player_idle_2.png
├── player_attack_0.png
├── player_attack_1.png
├── player_bullet_0.png  (子彈圖片，V0.5.0 使用)
├── player_bullet_1.png
├── player_bullet_2.png
└── player_hurt_0.png    (可選)
```

**命名規則：**
- 格式：`player_{action}_{frame}.png`
- action = 動作名稱 (idle, attack, hurt, bullet)
- frame = 幀編號，從 0 開始
- 格式：PNG，透明背景
- 建議尺寸：128x128 或 256x256

---

## 步驟 2：角色類別設計

建立 `src/entities/Player.ts`：

```typescript
import Phaser from 'phaser';
import { UNIT_SIZE } from '../config/GameConfig';

export type PlayerState = 'idle' | 'attack' | 'hurt';

/**
 * 玩家角色
 * - 大小：1 單位 (畫面高度的 10%)
 * - 跟隨滑鼠/觸控位置移動
 * - 左鍵按住：移動 + 發射子彈
 * - 右鍵：施放技能
 */
export class Player extends Phaser.GameObjects.Sprite {
  private currentState: PlayerState = 'idle';
  private moveSpeed: number = 800;
  private targetPos: Phaser.Math.Vector2 | null = null;

  constructor(scene: Phaser.Scene, x: number, y: number) {
    // 使用第一張 idle 圖片作為初始材質
    super(scene, x, y, 'player-idle-0');
    scene.add.existing(this as Phaser.GameObjects.Sprite);

    this.setDepth(10);

    // 設定角色大小為 1 單位
    this.setUnitSize(1);
  }

  /**
   * 設定角色大小 (以單位為基準)
   * @param units 單位數 (1 單位 = 畫面高度 10%)
   */
  setUnitSize(units: number): this {
    const targetSize = UNIT_SIZE * units;
    // 以較大邊為基準縮放，確保完整顯示
    const maxDimension = Math.max(this.width, this.height);
    const scale = targetSize / maxDimension;
    this.setScale(scale);
    return this;
  }

  /**
   * 初始化動畫 (需在資源載入後呼叫)
   */
  initAnimations(frameConfig: { [key: string]: number }): void {
    // idle 動畫
    if (!this.scene.anims.exists('player-idle')) {
      this.scene.anims.create({
        key: 'player-idle',
        frames: this.generateFrames('player-idle', frameConfig['idle'] || 1),
        frameRate: 8,
        repeat: -1,
      });
    }

    // attack 動畫
    if (!this.scene.anims.exists('player-attack')) {
      this.scene.anims.create({
        key: 'player-attack',
        frames: this.generateFrames('player-attack', frameConfig['attack'] || 1),
        frameRate: 12,
        repeat: -1,
      });
    }

    // hurt 動畫
    if (!this.scene.anims.exists('player-hurt')) {
      this.scene.anims.create({
        key: 'player-hurt',
        frames: this.generateFrames('player-hurt', frameConfig['hurt'] || 1),
        frameRate: 10,
        repeat: 0,
      });
    }

    this.play('player-idle');
  }

  /**
   * 產生動畫幀陣列
   */
  private generateFrames(key: string, count: number): Phaser.Types.Animations.AnimationFrame[] {
    const frames: Phaser.Types.Animations.AnimationFrame[] = [];
    for (let i = 0; i < count; i++) {
      frames.push({ key: `${key}-${i}` });
    }
    return frames;
  }

  /**
   * 設定角色狀態
   */
  setPlayerState(state: PlayerState): void {
    if (this.currentState === state) return;
    this.currentState = state;

    switch (state) {
      case 'idle':
        this.play('player-idle');
        break;
      case 'attack':
        this.play('player-attack');
        break;
      case 'hurt':
        this.play('player-hurt');
        this.once('animationcomplete', () => this.setPlayerState('idle'));
        break;
    }
  }

  /**
   * 設定目標位置 (滑鼠/觸控位置)
   */
  setTargetPosition(pos: Phaser.Math.Vector2 | null): void {
    this.targetPos = pos;
  }

  /**
   * 每幀更新
   */
  update(delta: number): void {
    if (!this.targetPos) return;

    const dx = this.targetPos.x - this.x;
    const dy = this.targetPos.y - this.y;
    const distance = Math.sqrt(dx * dx + dy * dy);

    // 到達目標位置附近就停止
    if (distance < 5) return;

    // 計算移動量
    const moveDistance = this.moveSpeed * (delta / 1000);
    const ratio = Math.min(moveDistance / distance, 1);

    let newX = this.x + dx * ratio;
    let newY = this.y + dy * ratio;

    // 畫面邊界限制
    const halfW = this.displayWidth / 2;
    const halfH = this.displayHeight / 2;
    const screenW = this.scene.scale.width;
    const screenH = this.scene.scale.height;

    newX = Phaser.Math.Clamp(newX, halfW, screenW - halfW);
    newY = Phaser.Math.Clamp(newY, halfH, screenH - halfH);

    this.setPosition(newX, newY);
  }

  getState(): PlayerState {
    return this.currentState;
  }
}
```

---

## 步驟 3：資源載入輔助函式

建立 `src/utils/AssetLoader.ts`：

```typescript
import Phaser from 'phaser';

/**
 * 動畫設定
 */
export interface AnimationConfig {
  key: string;        // 動作名稱 (idle, attack, hurt)
  frameCount: number; // 幀數
}

/**
 * 載入角色圖片資源
 * 檔案命名格式：{basePath}_{action}_{frame}.png
 * @param scene Phaser 場景
 * @param basePath 基礎路徑與前綴 (例如 'player')
 * @param animations 動畫設定陣列
 */
export function loadPlayerAssets(
  scene: Phaser.Scene,
  basePath: string,
  animations: AnimationConfig[]
): void {
  for (const anim of animations) {
    for (let i = 0; i < anim.frameCount; i++) {
      // key: player-idle-0, path: player/player_idle_0.png
      scene.load.image(
        `${basePath}-${anim.key}-${i}`,
        `${basePath}/${basePath}_${anim.key}_${i}.png`
      );
    }
  }
}
```

---

## 步驟 4：整合到 MainScene

更新 `src/scenes/MainScene.ts`：

```typescript
import Phaser from 'phaser';
import { getUIAnchors } from '../config/GameConfig';
import { ParallaxBackground } from '../systems/ParallaxBackground';
import { Player } from '../entities/Player';
import { loadPlayerAssets, AnimationConfig } from '../utils/AssetLoader';

/**
 * 主遊戲場景
 * V0.1.0: 基礎框架與輸入系統
 * V0.2.0: 視差背景系統 + EXPAND 縮放模式
 * V0.3.0: 角色系統
 */
export class MainScene extends Phaser.Scene {
  // #region 輸入系統
  private isLeftDown: boolean = false;
  // #endregion 輸入系統

  // #region 除錯顯示
  private debugText!: Phaser.GameObjects.Text;
  // #endregion 除錯顯示

  // #region 背景系統
  private parallaxBg!: ParallaxBackground;
  // #endregion 背景系統

  // #region 角色系統
  private player!: Player;
  private playerAnimConfig: AnimationConfig[] = [
    { key: 'idle', frameCount: 3 },
    { key: 'attack', frameCount: 2 },
    { key: 'hurt', frameCount: 1 },
  ];
  // #endregion 角色系統

  constructor() {
    super('MainScene');
  }

  preload(): void {
    // V0.2.0: 載入背景圖片
    this.load.image('bg_far', 'images/bg_far.png');
    this.load.image('bg_mid', 'images/bg_mid.png');

    // V0.3.0: 載入角色圖片
    loadPlayerAssets(this, 'player', this.playerAnimConfig);
  }

  create(): void {
    // V0.2.0: 初始化視差背景 (最先建立，確保在最底層)
    this.parallaxBg = new ParallaxBackground(this);
    this.parallaxBg.addLayer('bg_far', 0.1, 0);
    this.parallaxBg.addLayer('bg_mid', 0.6, 1);

    // V0.3.0: 建立玩家角色 (畫面左側中央)
    const frameConfig: { [key: string]: number } = {};
    for (const anim of this.playerAnimConfig) {
      frameConfig[anim.key] = anim.frameCount;
    }
    this.player = new Player(this, 200, this.scale.height / 2);
    this.player.initAnimations(frameConfig);

    this.setupInput();
    this.setupUI();

    // 監聽視窗大小變化
    this.scale.on('resize', this.onResize, this);
  }

  update(_time: number, delta: number): void {
    // V0.2.0: 更新背景捲動
    this.parallaxBg.update(delta);

    // V0.3.0: 更新角色
    this.player.update(delta);

    // 左鍵按住 = 攻擊狀態，否則 = idle
    if (this.isLeftDown) {
      this.player.setPlayerState('attack');
      // TODO: V0.5.0 發射子彈
    } else {
      if (this.player.getState() === 'attack') {
        this.player.setPlayerState('idle');
      }
    }

    // 更新除錯資訊
    this.updateDebugInfo(delta);
  }

  /**
   * 視窗大小變化時更新 UI 位置
   */
  private onResize(_gameSize: Phaser.Structs.Size): void {
    const anchors = getUIAnchors(this, 20);
    this.debugText.setPosition(anchors.topRight.x, anchors.topRight.y);
  }

  // #region UI 設定
  private setupUI(): void {
    const anchors = getUIAnchors(this, 20);

    this.debugText = this.add.text(anchors.topRight.x, anchors.topRight.y, '', {
      fontSize: '14px',
      color: '#00ff00',
      fontFamily: 'monospace',
      backgroundColor: '#000000aa',
      padding: { x: 8, y: 4 }
    }).setOrigin(1, 0).setDepth(100);
  }
  // #endregion UI 設定

  // #region 輸入處理
  private setupInput(): void {
    // 停用右鍵選單
    this.input.mouse!.disableContextMenu();

    // 滑鼠/觸控：左鍵按下 = 移動 + 攻擊
    this.input.on('pointerdown', (pointer: Phaser.Input.Pointer) => {
      if (pointer.leftButtonDown()) {
        this.isLeftDown = true;
        this.player.setTargetPosition(new Phaser.Math.Vector2(pointer.x, pointer.y));
      }
      if (pointer.rightButtonDown()) {
        this.onRightClick();
      }
    });

    this.input.on('pointermove', (pointer: Phaser.Input.Pointer) => {
      if (this.isLeftDown && pointer.leftButtonDown()) {
        this.player.setTargetPosition(new Phaser.Math.Vector2(pointer.x, pointer.y));
      }
    });

    this.input.on('pointerup', (pointer: Phaser.Input.Pointer) => {
      if (!pointer.leftButtonDown()) {
        this.isLeftDown = false;
        this.player.setTargetPosition(null);
      }
    });
  }

  /**
   * 右鍵施放技能
   */
  private onRightClick(): void {
    // TODO: V0.5.0 施放技能
    console.log('Right click - Skill cast');
  }
  // #endregion 輸入處理

  // #region 除錯 UI
  private updateDebugInfo(delta: number): void {
    const fps = Math.round(1000 / delta);
    const w = this.scale.width;
    const h = this.scale.height;
    const lines = [
      `FPS: ${fps}`,
      `Size: ${Math.round(w)}x${Math.round(h)}`,
      `Player: (${Math.round(this.player.x)}, ${Math.round(this.player.y)})`,
      `State: ${this.player.getState()}`,
      `L-Click: ${this.isLeftDown ? 'Down' : 'Up'}`,
    ];
    this.debugText.setText(lines.join('\n'));
  }
  // #endregion 除錯 UI
}
```

---

## 步驟 5：修正 Player 動畫載入

由於使用獨立圖片而非 Spritesheet，需調整 Player 的動畫產生方式：

更新 `src/entities/Player.ts` 的 `initAnimations` 方法：

```typescript
/**
 * 初始化動畫 (需在資源載入後呼叫)
 */
initAnimations(frameConfig: { [key: string]: number }): void {
  const actions = ['idle', 'attack', 'hurt'];

  for (const action of actions) {
    const animKey = `player-${action}`;
    if (this.scene.anims.exists(animKey)) continue;

    const frameCount = frameConfig[action] || 1;
    const frames: Phaser.Types.Animations.AnimationFrame[] = [];

    for (let i = 0; i < frameCount; i++) {
      frames.push({ key: `player-${action}-${i}` });
    }

    this.scene.anims.create({
      key: animKey,
      frames: frames,
      frameRate: action === 'attack' ? 12 : 8,
      repeat: action === 'hurt' ? 0 : -1,
    });
  }

  this.play('player-idle');
}
```

---

## 操作說明

| 操作 | 行為 |
|------|------|
| 左鍵按住拖曳 | 角色跟隨指標移動 + 進入攻擊狀態 |
| 左鍵放開 | 角色停止移動 + 回到 idle 狀態 |
| 右鍵點擊 | 施放技能 (V0.5.0 實作) |
| 方向鍵/WASD | 保留，但滑鼠操作優先 |

---

## 資源準備清單

在 `public/player/` 放置以下檔案：

| 動作 | 檔案 | 說明 |
|------|------|------|
| 待機 | `player_idle_0.png` ~ `player_idle_2.png` | 3 幀循環 |
| 攻擊 | `player_attack_0.png` ~ `player_attack_1.png` | 2 幀循環 |
| 受傷 | `player_hurt_0.png` | 1 幀，播放一次 |
| 子彈 | `player_bullet_0.png` ~ `player_bullet_2.png` | V0.5.0 使用 |

**圖片規格：**
- 格式：PNG (透明背景)
- 建議尺寸：128x128 像素
- 命名格式：`player_{action}_{frame}.png`

---

## 完成檢查清單

- [ ] `public/player/player_idle_0.png` 存在
- [ ] `public/player/player_attack_0.png` 存在
- [ ] 角色顯示在畫面左側
- [ ] 左鍵按住拖曳，角色跟隨移動
- [ ] 左鍵按住時，角色播放攻擊動畫
- [ ] 左鍵放開時，角色回到 idle 動畫
- [ ] 右鍵點擊有 console 輸出
- [ ] 角色不會超出畫面邊界
- [ ] 動畫正確循環播放
- [ ] 除錯資訊顯示角色位置與狀態
