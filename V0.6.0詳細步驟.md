# V0.6.0 - 技能數值系統 & UI 詳細步驟

## 數值規格

### 玩家 HP
| 項目 | 數值 |
|------|------|
| 最大 HP | 200 |
| 被子彈擊中 | -1 |
| 被怪物碰撞 | -3 |
| 碰撞無敵時間 | 500ms |

### 大技能能量
| 項目 | 數值 |
|------|------|
| 最大能量 | 500 |
| 擊中敵人 | +1 |
| 施放條件 | 能量 = 500 |
| 施放消耗 | 每 0.02 秒 -1 |
| 重新蓄能條件 | 能量歸零後 |

### 大技能金色子彈
| 項目 | 數值 |
|------|------|
| 發射方向 | 8 方向同時 |
| 發射間隔 | 50ms |
| 每輪旋轉 | +10 度 |
| 子彈速度 | 1200 px/s |
| 子彈傷害 | 3 點 |
| 特殊能力 | 打消敵方彈幕 |
| 視覺效果 | 淡金色 + 呼吸閃動 |

---

## 步驟 1：玩家數值管理

修改 `src/entities/Player.ts`，新增數值屬性：

```typescript
// 數值常數
const MAX_HP = 200;
const MAX_ENERGY = 500;
const BULLET_DAMAGE = 1;
const COLLISION_DAMAGE = 3;
const ENERGY_DRAIN_INTERVAL = 0.02; // 秒

export class Player extends Phaser.GameObjects.Sprite {
  // 數值
  private hp: number = MAX_HP;
  private energy: number = 0;
  private isUltActive: boolean = false;
  private energyDrainTimer: number = 0;

  // HP 相關
  getHP(): number { return this.hp; }
  getMaxHP(): number { return MAX_HP; }

  takeBulletDamage(): void {
    this.hp = Math.max(0, this.hp - BULLET_DAMAGE);
    this.onDamage();
  }

  takeCollisionDamage(): void {
    this.hp = Math.max(0, this.hp - COLLISION_DAMAGE);
    this.onDamage();
  }

  private onDamage(): void {
    this.setTint(0xff0000);
    this.scene.time.delayedCall(100, () => this.clearTint());
    this.setPlayerState('hurt');
  }

  isDead(): boolean {
    return this.hp <= 0;
  }

  // 能量相關
  getEnergy(): number { return this.energy; }
  getMaxEnergy(): number { return MAX_ENERGY; }

  addEnergy(amount: number = 1): void {
    if (this.isUltActive) return; // 施放中不累計
    this.energy = Math.min(MAX_ENERGY, this.energy + amount);
  }

  canUseUlt(): boolean {
    return this.energy >= MAX_ENERGY && !this.isUltActive;
  }

  activateUlt(): boolean {
    if (!this.canUseUlt()) return false;
    this.isUltActive = true;
    this.energyDrainTimer = 0;
    return true;
  }

  isUltimateActive(): boolean {
    return this.isUltActive;
  }

  updateEnergy(delta: number): void {
    if (!this.isUltActive) return;

    this.energyDrainTimer += delta / 1000;

    while (this.energyDrainTimer >= ENERGY_DRAIN_INTERVAL) {
      this.energyDrainTimer -= ENERGY_DRAIN_INTERVAL;
      this.energy -= 1;

      if (this.energy <= 0) {
        this.energy = 0;
        this.isUltActive = false;
        break;
      }
    }
  }
}
```

---

## 步驟 2：大技能金色子彈

修改 `src/data/BulletData.ts`，新增大技能子彈定義：

```typescript
// 大技能金色子彈
export const ULTIMATE_BULLET: BulletDef = {
  key: 'player-bullet',  // 使用同樣的圖片，會染成金色
  speed: 1200,           // 高速
  damage: 3,             // 3 點傷害
  size: 12,
  unitSize: 0,
  frameCount: 2,
};
```

修改 `src/entities/Bullet.ts`，新增大技能標記與呼吸效果：

```typescript
export class Bullet extends Phaser.GameObjects.Sprite {
  private ultimate: boolean = false;
  private breathTimer: number = 0;

  constructor(
    scene: Phaser.Scene,
    x: number,
    y: number,
    angle: number,
    def: BulletDef,
    owner: BulletOwner,
    turnAfterUnits: number = 0,
    isUltimate: boolean = false  // 新增參數
  ) {
    // ... 現有程式碼 ...

    this.ultimate = isUltimate;

    // 大技能子彈染成淡金色
    if (isUltimate) {
      this.setTint(0xffee88);
    }
  }

  update(delta: number): void {
    // ... 現有移動邏輯 ...

    // 大技能子彈呼吸閃動效果
    if (this.ultimate) {
      this.breathTimer += delta;
      const alpha = 0.6 + 0.4 * Math.sin(this.breathTimer * 0.015);
      this.setAlpha(alpha);
    }
  }

  isUltimate(): boolean {
    return this.ultimate;
  }
}
```

修改 `src/systems/BulletSystem.ts`，新增發射方法：

```typescript
import { ULTIMATE_BULLET } from '../data/BulletData';

// 發射大技能金色子彈
fireUltimate(x: number, y: number, angleDeg: number): Bullet {
  const angleRad = Phaser.Math.DegToRad(angleDeg);
  return this.fire(x, y, angleRad, ULTIMATE_BULLET, 'player', 0, true);
}

// 取得大技能子彈
getUltimateBullets(): Bullet[] {
  return this.bullets.filter(b => b.isUltimate());
}
```

---

## 步驟 3：碰撞檢測

修改 `src/systems/MonsterSystem.ts`，新增玩家碰撞檢測：

```typescript
import { Player } from '../entities/Player';

checkPlayerCollision(player: Player): boolean {
  let collided = false;
  for (const monster of this.monsters) {
    if (!monster.isAlive()) continue;

    const dist = Phaser.Math.Distance.Between(
      monster.x, monster.y,
      player.x, player.y
    );
    const hitRadius = monster.displayWidth / 2 + player.getRadius();

    if (dist < hitRadius) {
      player.takeCollisionDamage();
      collided = true;
    }
  }
  return collided;
}
```

修改 `src/scenes/MainScene.ts`，新增子彈對消：

```typescript
private checkCollisions(): void {
  const ultimateBullets = this.bulletSystem.getUltimateBullets();
  const monsterBullets = this.bulletSystem.getMonsterBullets();

  // 大技能金色子彈 vs 敵方彈幕 (打消)
  for (const ultBullet of ultimateBullets) {
    for (const mobBullet of monsterBullets) {
      const dist = Phaser.Math.Distance.Between(
        ultBullet.x, ultBullet.y,
        mobBullet.x, mobBullet.y
      );
      const hitRadius = ultBullet.getRadius() + mobBullet.getRadius();
      if (dist < hitRadius) {
        // 金色子彈打消敵方彈幕，但金色子彈不消失
        this.bulletSystem.removeBullet(mobBullet);
      }
    }
  }

  // ... 其他碰撞檢測 ...
}
```

---

## 步驟 4：UI 系統

建立 `src/ui/StatusBar.ts`：

```typescript
import Phaser from 'phaser';

export class StatusBar {
  private x: number;
  private y: number;
  private width: number;
  private height: number;
  private background: Phaser.GameObjects.Graphics;
  private fill: Phaser.GameObjects.Graphics;
  private fillColor: number;

  constructor(
    scene: Phaser.Scene,
    x: number, y: number,
    width: number, height: number,
    color: number
  ) {
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
    this.fillColor = color;

    this.background = scene.add.graphics();
    this.background.fillStyle(0x333333, 0.8);
    this.background.fillRoundedRect(x, y, width, height, 4);
    this.background.setDepth(100);

    this.fill = scene.add.graphics();
    this.fill.setDepth(100);
    this.setValue(1);
  }

  setValue(percent: number): void {
    percent = Phaser.Math.Clamp(percent, 0, 1);
    this.fill.clear();
    this.fill.fillStyle(this.fillColor, 1);
    const fillWidth = (this.width - 4) * percent;
    if (fillWidth > 0) {
      this.fill.fillRoundedRect(
        this.x + 2, this.y + 2,
        fillWidth, this.height - 4,
        3
      );
    }
  }

  destroy(): void {
    this.background.destroy();
    this.fill.destroy();
  }
}
```

建立 `src/ui/PlayerHUD.ts`：

```typescript
import Phaser from 'phaser';
import { StatusBar } from './StatusBar';

export class PlayerHUD {
  private hpBar: StatusBar;
  private energyBar: StatusBar;
  private hpText: Phaser.GameObjects.Text;
  private energyText: Phaser.GameObjects.Text;

  constructor(scene: Phaser.Scene) {
    const padding = 20;
    const barWidth = 200;

    // HP 條 (紅色)
    this.hpBar = new StatusBar(scene, padding, padding, barWidth, 20, 0xff4444);
    this.hpText = scene.add.text(padding + barWidth + 8, padding, '200/200', {
      fontSize: '16px',
      color: '#ffffff',
    }).setDepth(100);

    // 能量條 (黃色)
    this.energyBar = new StatusBar(scene, padding, padding + 28, barWidth, 14, 0xffcc00);
    this.energyText = scene.add.text(padding + barWidth + 8, padding + 26, '0/500', {
      fontSize: '12px',
      color: '#ffcc00',
    }).setDepth(100);
  }

  updateHP(current: number, max: number): void {
    this.hpBar.setValue(current / max);
    this.hpText.setText(`${Math.ceil(current)}/${max}`);
  }

  updateEnergy(current: number, max: number): void {
    this.energyBar.setValue(current / max);
    this.energyText.setText(`${Math.ceil(current)}/${max}`);
    this.energyText.setColor(current >= max ? '#ffffff' : '#ffcc00');
  }

  destroy(): void {
    this.hpBar.destroy();
    this.energyBar.destroy();
    this.hpText.destroy();
    this.energyText.destroy();
  }
}
```

建立 `src/ui/GameOverScreen.ts`：

```typescript
import Phaser from 'phaser';

export class GameOverScreen {
  private container: Phaser.GameObjects.Container;
  private overlay: Phaser.GameObjects.Graphics;

  constructor(scene: Phaser.Scene, survivalTime: number) {
    const { width, height } = scene.cameras.main;

    this.overlay = scene.add.graphics();
    this.overlay.fillStyle(0x000000, 0.7);
    this.overlay.fillRect(0, 0, width, height);
    this.overlay.setDepth(199);

    this.container = scene.add.container(width / 2, height / 2);
    this.container.setDepth(200);

    const title = scene.add.text(0, -80, 'GAME OVER', {
      fontSize: '64px',
      color: '#ff4444',
      fontStyle: 'bold',
    }).setOrigin(0.5);

    const timeText = scene.add.text(0, 0, `存活時間: ${Math.floor(survivalTime)} 秒`, {
      fontSize: '32px',
      color: '#ffffff',
    }).setOrigin(0.5);

    const restartBtn = scene.add.text(0, 80, '[ 重新開始 ]', {
      fontSize: '36px',
      color: '#ffcc00',
    }).setOrigin(0.5).setInteractive({ useHandCursor: true });

    restartBtn.on('pointerover', () => restartBtn.setColor('#ffffff'));
    restartBtn.on('pointerout', () => restartBtn.setColor('#ffcc00'));
    restartBtn.on('pointerdown', () => {
      this.destroy();
      scene.scene.restart();
    });

    this.container.add([title, timeText, restartBtn]);
  }

  destroy(): void {
    this.overlay.destroy();
    this.container.destroy();
  }
}
```

---

## 步驟 5：MainScene 整合

修改 `src/scenes/MainScene.ts`：

```typescript
import { PlayerHUD } from '../ui/PlayerHUD';
import { GameOverScreen } from '../ui/GameOverScreen';

export class MainScene extends Phaser.Scene {
  private hud!: PlayerHUD;
  private survivalTime: number = 0;
  private isGameOver: boolean = false;
  private collisionCooldown: number = 0;
  private readonly COLLISION_COOLDOWN = 500;

  // 大技能旋轉掃射
  private ultAngle: number = 0;
  private ultFireTimer: number = 0;
  private readonly ULT_FIRE_INTERVAL = 50;
  private readonly ULT_ANGLE_STEP = 10;
  private readonly ULT_DIRECTIONS = 8;

  // 場景初始化 (重新開始時呼叫)
  init(): void {
    this.isLeftDown = false;
    this.fireTimer = 0;
    this.survivalTime = 0;
    this.isGameOver = false;
    this.collisionCooldown = 0;
    this.ultAngle = 0;
    this.ultFireTimer = 0;
  }

  create(): void {
    // ... 現有程式碼 ...
    this.hud = new PlayerHUD(this);
  }

  update(_time: number, delta: number): void {
    if (this.isGameOver) return;

    this.survivalTime += delta / 1000;
    this.player.updateEnergy(delta);

    // 大技能旋轉掃射
    if (this.player.isUltimateActive()) {
      this.ultFireTimer += delta;
      while (this.ultFireTimer >= this.ULT_FIRE_INTERVAL) {
        this.ultFireTimer -= this.ULT_FIRE_INTERVAL;
        const angleStep = 360 / this.ULT_DIRECTIONS;
        for (let i = 0; i < this.ULT_DIRECTIONS; i++) {
          const angle = this.ultAngle + angleStep * i;
          this.bulletSystem.fireUltimate(this.player.x, this.player.y, angle);
        }
        this.ultAngle += this.ULT_ANGLE_STEP;
        if (this.ultAngle >= 360) this.ultAngle -= 360;
      }
    }

    // 怪物碰撞 (帶冷卻)
    if (this.collisionCooldown > 0) {
      this.collisionCooldown -= delta;
    } else if (this.monsterSystem.checkPlayerCollision(this.player)) {
      this.collisionCooldown = this.COLLISION_COOLDOWN;
    }

    // 更新 HUD
    this.hud.updateHP(this.player.getHP(), this.player.getMaxHP());
    this.hud.updateEnergy(this.player.getEnergy(), this.player.getMaxEnergy());

    // 檢查死亡
    if (this.player.isDead()) {
      this.gameOver();
    }
  }

  private gameOver(): void {
    this.isGameOver = true;
    new GameOverScreen(this, this.survivalTime);
  }

  private onRightClick(): void {
    if (this.player.activateUlt()) {
      this.ultAngle = 0;
      this.ultFireTimer = 0;
    }
  }
}
```

---

## 完成檢查清單

### 數值系統
- [x] 玩家 HP 最大 200
- [x] 被子彈擊中 -1 HP
- [x] 被怪物碰撞 -3 HP (500ms 冷卻)
- [x] HP 歸零觸發死亡

### 大技能系統
- [x] 擊中敵人 +1 能量
- [x] 能量最大 500
- [x] 能量滿時右鍵可施放
- [x] 施放中每 0.02 秒 -1 能量
- [x] 能量歸零後停止施放
- [x] 施放中不累計能量
- [x] 8 方向金色子彈旋轉掃射
- [x] 每輪 +10 度
- [x] 金色子彈傷害 3 點
- [x] 金色子彈打消敵方彈幕
- [x] 淡金色 + 呼吸閃動效果

### UI
- [x] HP 條正確顯示
- [x] 能量條正確顯示
- [x] 死亡結算畫面顯示
- [x] 重新開始按鈕可用
- [x] 重新開始後狀態正確重置
